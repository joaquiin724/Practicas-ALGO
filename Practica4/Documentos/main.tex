\documentclass[11pt,openany]{book}
\input{assets/portada.tex}
\usepackage{assets/formulas}
\usepackage[mathscr]{euscript}
\usepackage{bm}
\usepackage{float}
\hbadness=10000 % Suppress Underfull \hbox warnings

%========================================|Indice|===============================================%

\begin{document}
\portada{Algorítmica}{2023-2024}{Miguel Ángel De la Vega Rodríguez}{https://github.com/Miguevrgo/}{github.png}
\tableofcontents % Índice
\newpage %Salto de pagina tras el Indice


%======================================|Documento|==============================================%
\chapter{Autores}
\begin{itemize}
      \item \textbf{Miguel Ángel De la Vega Rodríguez:} 20\%
            \begin{itemize}
                  \item Makefile | Organización Branch and Bound
                  \item Programación Branch and Bound
                  \item Branch and bound redacción
            \end{itemize}
      \item \textbf{Joaquín Avilés De la Fuente:} 20\%
            \begin{itemize}
                  \item Programación Branch and Bound
                  \item Programación creación de casos (puntos y matrices de adyacencia)
                  \item Programación de funciones de cota para Branch and Bound
            \end{itemize}
      \item \textbf{Alberto De la Vera Sánchez: } 20\%
            \begin{itemize}
                  \item Branch and bound redacción
            \end{itemize}
      \item \textbf{Manuel Gomez Rubio} 20\%
            \begin{itemize}
                \item Programacion Backtracking
                \item Redacción Backtracking
            \end{itemize}
      \item \textbf{Pablo Linari Pérez:} 20\%
            \begin{itemize}
                  \item Programacion Backtracking
                  \item Redacción Objetivos
                  \item Redacción Backtracking
            \end{itemize}
\end{itemize}

\chapter{Equipo de trabajo}

\begin{itemize}
      \item \textbf{Miguel Ángel De la Vega Rodríguez:} (Ordenador donde se ha realizado el computo)
            \begin{itemize}
                  \item AMD Ryzen 7 2700X 8-Core
                  \item 16 GB RAM DDR4 3200 MHz
                  \item NVIDIA GeForce GTX 1660 Ti
                  \item 1 TB SSD NvMe
                  \item Debian 12 Bookworm
                  \item Compilador GCC 12.2.0
            \end{itemize}
\end{itemize}

\chapter{Objetivos}
    El objetivo de esta práctica es resolver el problema del viajante de comercio el cual viene descrito por el siguiente enunciado :\
    Tenemos un conjunto de n ciudades (puntos en un plano), cada una definida por las coordenadas en el mapa $(x_i , y_i )$, con $i = 1, . . . , n$. La distancia entre dos ciudades viene dada por la
    distancia euclídea entre sus coordenadas.
    El problema de viajante de comercio consiste en encontrar el orden en el que un viajante,
    partiendo de la ciudad de origen (por ejemplo $(x_1 , y_1 )$) pase por todas y cada una de las ciudades
    una única vez, para volver a la ciudad de partida, formando un ciclo. \ 

    Para ello usaremos dos diseños distintos de  algoritmos dedicados a la exploraciónde grafos , backtracking y brannch and bound 
    con el objetivo de ver las diferencias entre la eficiencia de estos dos algoritmos. Además se probarán distintas funciones de cotsa 
    para estudiar que influencia tienen en cada caso las distintas funciones.Por último se realizará un estudio tanto teórico como 
    empírico de la eficiencia de los algoritmos implementados.
\chapter{Backtracking}   
\section{Diseño}   
En esta sección analizaremos el algorimo de exploración de grafos llamado Backtracking, que consiste en recorrer todos los caminos en profundidad obteniendo todas
las posibles soluciones al problema. \\
Para seleccionar la solución más óptima del problema debemos ir comparando con la anterior posible solución  cada vez que obtenemos una nueva solución al problema, quedándonos con la que más nos
convenga, en este caso, la que nos de un camino de menor disatancia.
\\ \\
Hay varias formas de hacerlo:
\begin{itemize}
      \item La primera forma consiste en hacerlo mediante fuerza bruta, es decir, usar la definición al uso de Backtracking recorriendo todos los caminos sin preocuparnos
      si estos nos permiten alcanzar una solución mejor que la obtenida anteriormente.
      \item La otra forma es implementar una función de cota, esto nos permite decidir si seguimos explorando el camino seleccionado porque nos puede dar un resultado mejor
      o si es mejor abandonarlo, ya que no se obtendrá una mejora.
      Esta forma de realizarlo será, como es lógico, más eficiente.
\end{itemize}

Para la implementación del algoritmo, optamos por la segunda forma, usando diferentes funciones de cota que nos permitan aproximar si el camino seleccionado es bueno.A continuación
veremos como se ha elegido cada cota .
\subsection{Cota global}

\begin{lstlisting}
    vector<int> nearest_neighbourTSP(const vector<vector<double>>& distancias, int inicial) {
    int num_puntos = distancias.size();
    vector<int> camino;
    vector<bool> visitados(num_puntos, false);
    camino.reserve(num_puntos);
    camino.push_back(inicial);
    visitados[inicial] = true;

    for (int i = 0; i < num_puntos - 1; ++i) {
        int actual = camino.back();
        int siguiente = -1;
        double min_distancia = numeric_limits<double>::max();

        for (int j = 0; j < num_puntos; ++j) {
            if (!visitados[j] && distancias[actual][j] < min_distancia) {
                min_distancia = distancias[actual][j];
                siguiente = j;
            }
        }

        camino.push_back(siguiente);
        visitados[siguiente] = true;
    }

    camino.push_back(inicial);
    return camino;
}
\end{lstlisting} 
Esta funcion de la practica anterior la usaremos par obtener una cota global, ya que nos proporciona una solución al problema del viajante, aunque no sea la mejor, nos servirá para comparar
Si la decision que toma nuestro algoritmo es mejor que la que nos proporciona esta función. 

\subsection{Cota local}
\textbf{Primera función de cota:} \\
    La primera función de cota que hemos implementado consiste en calcular el mínimo valor de los arcos del grafo que no han sido 
    usados todavía , se multiplican por el numero de nodos restantes y se suman al coste actual.
    \begin{lstlisting}
        double cota1(const vector<vector<double>> &graph, const vector<int> &solucion,double c_actual, double arco_menorpeso) {
            return arco_menorpeso * (graph.size() - solucion.size() + 1) + c_actual;
        }

    \end{lstlisting}
\textbf{Segunda función de cota:} \\
    La segunda función de cota que hemos implementado consiste en calcular el mínimo valor de salir de todos los nodos del grafo que no 
    han sido visitados y sumarle la distancia del recorrido actual.
    En el siguiente codigose recorre la matriz de adyacencia y se selecciona el menor valor de los arcos de los nodos que no han sido visitados 
    y se suman al coste actual.
    \begin{lstlisting}
        double cota2(const vector<vector<double>> &graph, const vector<int> &solucion,=double c_actual) {
            double cota = 0;
            vector<double> v;
            double min = numeric_limits<double>::max();
            for (int i = 1; i < graph.size(); ++i) {
                if ((find(solucion.begin(), solucion.end(), i) == solucion.end())) {
                    v = graph[i];
                    sort(v.begin(), v.end());
                    cota += v[1];
                }
            }
            return cota + c_actual;
        }
    \end{lstlisting}
    \textbf{Tercera función de cota:} \\
    La tercera función de cota que hemos implementado consiste en calcular el mínimo valor de salir y entrar  de todos los nodos del grafo que no 
    han sido visitados ,hacer la media  y sumarle la distancia del recorrido actual.
    El siguiente codigo busca en una matriz de adyacencia los valores de los arcos de los nodos que no han sido todavia visitados , se 
    seleccionan todos ellos y se ordenande menor a mayor para seleccionar los dos menores y hacer la media de estos.
    \begin{lstlisting}
        double cota3(const vector<vector<double>> &graph, const vector<int> &solucion,double c_actual) {
            double cota = 0;
            vector<double> v;
            double min = numeric_limits<double>::max();
            for (int i = 1; i < graph.size(); ++i) {
                if ((find(solucion.begin(), solucion.end(), i) == solucion.end())) {
                    v = graph[i];
                    sort(v.begin(), v.end());
                    cota += (v[1] + v[2]) / 2;
                }
            }
            return cota + c_actual;
        }
    \end{lstlisting}
\subsection{Algoritmo Backtracking}
A continuación se muestra el algoritmo de Backtracking implementado:

\begin{lstlisting}
/**
 * @brief Funcion para resolver el tsp con backtracking .
 * @param solucion vector de ciudades , la posicion de la ciudad indica el orden
 * en el que es visitada
 * @param graph graph de adyacencia
 * @param c_mejor mejor coste encontrado
 * @param s_mejor mejor solucion encontrada
 * @param c_actual coste actual
 * @param arco_menorpeso arco de menor peso del grafo (para no tener que calcularlo siempre)
 *@param cota cota a utilizar
 */
 void tsp_backtracking(vector<int> &solucion,const vector<vector<double>> &graph, double &c_mejor,vector<int> &s_mejor, double c_actual, int arco_menorpeso,int cota = 0) {
  c_actual += solucion.size() <= 1? 0: graph[solucion.back()][solucion[solucion.size() - 2]];
  if (solucion.size() == graph.size()) {
    c_actual += graph[solucion.back()][solucion[0]];
    if (c_actual < c_mejor) {
      c_mejor = c_actual;
      s_mejor = solucion;
    }
  } else {
    for (int i = 1; i < graph.size(); i++) {
      if (find(solucion.begin(), solucion.end(), i) == solucion.end()) {
        double acotacion;
        if (cota == 1) {
            acotacion = cota1(graph, solucion, c_actual, arco_menorpeso);
        } else if (cota == 2) {
            acotacion = cota2(graph, solucion, c_actual);
        } else if (cota == 3) {
            acotacion = cota3(graph, solucion, c_actual);
        } else {
            acotacion = 0;
        }
        if (acotacion <= c_mejor) {
            solucion.emplace_back(i);
            tsp_backtracking(solucion, graph, c_mejor, s_mejor, c_actual,arco_menorpeso, cota);
            solucion.pop_back();
          }
      }
    }
  }
}

  
                
    \end{lstlisting}
    El algoritmo recive como parametros una matriz de adyacencia , un vector de enteros que representa la solución actual, un vector de enteros que representa la mejor solución encontrada, un double que representa el mejor coste encontrado, un double que representa el coste actual, un entero que representa el arco de menor peso del grafo y un entero que representa la cota a utilizar.
    El vector de enteros solucion contiene el punto inicial sobre el que se aplica el algoritmo , si el vector solución está completo se comprueba si 
    la solución obtenida es mejor que la que se tenía y se actualiza en caso de serlo. Si no está completo se calcula la cota local y se  añade un nuevo punto al vector solución y se llama a la función recursivamente hasta que encuentra un camino completo.
    
\section{Justificación}
Para la justificación del Backtracking debemos comprobar que se obtiene la mejor solución posible, en nuestro caso, esa demostración la haremos usando reducción al absurdo:
\begin{enumerate}
    \item Llamaremos n al conjunto de todos los nodos
    \item Llamaremos $C_l$ a la cota local 
    \item Llamaremos C a la cota global
    \item La solución óptima se obtendrá tras haber explorado todas las ramas llegando al final, o no, dependiendo de los valores de las cotas
\end{enumerate}
Para la demostración empezaremos del algorimo supondremos que la solución K obtenida no es la solución óptima, esto implica que existe otra forma de explorar el grafo teniéndose que $K>K'$ siendo K' la solución óptima.
Al devolver nuestro algorimo K, la cota global contendrá precisamente este valor, cosa que nos lleva a una contradicción, ya que si una vez explorado todo el grafo hubiera una solución mejor que K, la cota global del programa deberá ser igual 
a ella, que en nuestro caso no ocurre, o bien porque la $C_l$ ha hecho que se descarte la exploración de esa rama, o bien porque se exploró completamente sin mejorar la solución que ya teníamos.

\section{Eficiencia teórica y empírica}
\subsection{Eficiencia empírica}
\begin{figure}[H]
    \centering
    \begin{minipage}{.48\textwidth}
          \centering
          \includegraphics[width=1\linewidth]{assets/Img/grafico_tiemposbk.png}
          \caption{Cota 1}
          \label{fig:Cota 1}
    \end{minipage}%
    \begin{minipage}{.48\textwidth}
          \centering
          \includegraphics[width=1\linewidth]{assets/Img/grafico_tiempos2.png}
          \caption{Cota 3}
          \label{fig:Cota 3}
    \end{minipage}
\begin{minipage}{.48\textwidth}
      \centering
      \includegraphics[width=1\linewidth]{assets/Img/grafico_tiempos.png}
      \caption{Cota 2}
      \label{fig:Cota 3}
\end{minipage}
\end{figure}
\newpage
\subsection{Eficiencia teórica}
La eficiencia teórica del algorimo es factorial, puesto las dos funciones de cota de dentro del código son $O(n)$, la primera es constante y la llamada recursiva es n! luego al estar en el for ($O(n)$)
obtenemos que la eficiencia teórica del algoritmo es de $O(n!)$

\chapter{Branch and Bound}
En esta sección, abordamos la resolución del problema del viajante utilizando el algoritmo Branch and Bound. A diferencia del método de backtracking empleado anteriormente, este enfoque permite una exploración más eficiente del espacio de soluciones. Describiremos las funciones de cota utilizadas y el algoritmo principal.

\section{Diseño}
\subsection{Cota Global}
Para la cota global, utilizamos la función "nearest neighbour" desarrollada en la práctica anterior. Esta función proporciona una cota superior inicial, que sirve como referencia para comparar las soluciones que nuestro algoritmo vaya generando. La cota global es crucial, ya que ayuda a reducir el número de nodos a explorar al proporcionar un límite superior sobre el cual los nodos con cotas inferiores son evaluados.
\begin{lstlisting}
vector<int> nearest_neighbourTSP(const vector<vector<double>>& distancias, int inicial) {
    int num_puntos = distancias.size();
    vector<int> camino;
    vector<bool> visitados(num_puntos, false);
    camino.reserve(num_puntos);
    camino.push_back(inicial);
    visitados[inicial] = true;

    for (int i = 0; i < num_puntos - 1; ++i) {
      int actual = camino.back();
      int siguiente = -1;
      double min_distancia = numeric_limits<double>::max();

      for (int j = 0; j < num_puntos; ++j) {
          if (!visitados[j] && distancias[actual][j] < min_distancia) {
              min_distancia = distancias[actual][j];
              siguiente = j;
          }
      }

      camino.push_back(siguiente);
      visitados[siguiente] = true;
    }

    camino.push_back(inicial);
    return camino;
}

\end{lstlisting} 

      
\subsection{Cota local}

Además de la cota global, hemos implementado tres funciones de cota local diferentes para estimar de manera 
más precisa el costo de completar un camino parcial. Estas funciones nos ayudan a determinar si es 
prometedor continuar expandiendo un nodo dado en el árbol de soluciones.
\begin{itemize}
    \item La primera cota local calcula el mínimo de cada fila en una matriz de distancias, excluyendo tanto los valores de 0 (que representan la distancia de un nodo a sí mismo) como los nodos específicos indicados en un vector de índices a ignorar. Este método asegura que no se considere volver a visitar los mismos nodos, proporcionando una suma de los mínimos costos posibles restantes.
    \item La segunda cota local opera de manera distinta. Encuentra la mínima distancia global en la matriz y multiplica este valor por el número de filas restantes, suponiendo que este mínimo es representativo del costo de conectar todos los nodos restantes. Aunque esta cota es más restrictiva, suele proporcionar una estimación más cercana al costo real, permitiendo podar más efectivamente el árbol de búsqueda.
\end{itemize}

Veamos la implementación de las 3:
\begin{lstlisting}
double cota_inferior_1(const vector<vector<double>>& matriz, const vector<int>& indices_a_ignorar = {}) {
    double suma_minimos = 0.0;

    for (int i = 0; i < matriz.size(); ++i) {
        
        if (find(indices_a_ignorar.begin(), indices_a_ignorar.end(), i) != indices_a_ignorar.end()) {
            continue;
        }

        double minimo_fila = numeric_limits<double>::max();
        for (int j = 0; j < matriz[i].size(); ++j) {
            
            if (find(indices_a_ignorar.begin(), indices_a_ignorar.end(), j) != indices_a_ignorar.end()) {
                continue;
            }
            if (matriz[i][j] > 0 && matriz[i][j] < minimo_fila) {
                minimo_fila = matriz[i][j];
            }
        }

        if (minimo_fila < numeric_limits<double>::max()) {
            suma_minimos += minimo_fila;
        }
    }

    return suma_minimos;
}    

double cota_inferior_2(const vector<vector<double>>& matriz, const vector<int>& indices_a_ignorar = {}) {
    double min_global = numeric_limits<double>::max();
    int filas_contadas = 0;

    for (int i = 0; i < matriz.size(); ++i) {
        
        if (find(indices_a_ignorar.begin(), indices_a_ignorar.end(), i) != indices_a_ignorar.end()) {
            continue;
        }

        double minimo_fila = numeric_limits<double>::max();
        for (int j = 0; j < matriz[i].size(); ++j) {
            
            if (find(indices_a_ignorar.begin(), indices_a_ignorar.end(), j) != indices_a_ignorar.end()) {
                continue;
            }
            if (matriz[i][j] > 0 && matriz[i][j] < minimo_fila) {
                minimo_fila = matriz[i][j];
            }
        }

        if (minimo_fila < numeric_limits<double>::max()) {
            if (minimo_fila < min_global) {
                min_global = minimo_fila;
            }
            ++filas_contadas;
        }
    }

    return  (min_global * filas_contadas);
}
            
\end{lstlisting}

Más adelante en el apartado de eficiencia seguiremos comparando dichas cotas.

\subsection{Algoritmo Branch and Bound}
Primero de todo, el struct con el que trabajaremos para almacenar la información sobre la cota mínima, el camino y la distancia recorrida será:

\begin{lstlisting}
      struct Nodo {
            vector<int> path;
            double distancia_recorrida; 
            double cota_inferior; 
        
            Nodo(vector<int>& inicial, double dist_rec, double cota_inf) {
                path = inicial;
                distancia_recorrida = dist_rec;
                cota_inferior = cota_inf;
            }
      };
\end{lstlisting}

Ahora, el algoritmo Brach and Bound que hemos implementado ha sido:

\begin{lstlisting}
vector<int> branch_and_bound_greedy(vector<int>& points, vector< vector<double>> &distancias, int inicial){
    priority_queue<Nodo, vector<Nodo>, Comparador> no_visitados;
    vector<int> mejor_camino = {inicial};
    Nodo actual( mejor_camino, 0, cota_inferior(distancias));
    no_visitados.push(actual);

    double costo_minimo = calcularDistanciaTotal(distancias, nearest_neighbourTSP(distancias, inicial));
    mejor_camino.clear();

    while (!no_visitados.empty()) {
        actual = no_visitados.top();
        no_visitados.pop();

        if (actual.path.size() == points.size()-1) {
            vector<int> faltantes= numeros_faltantes(actual.path, points.size()-1);
            actual.distancia_recorrida += distancias[actual.path.back()][faltantes[0]];
            actual.distancia_recorrida += distancias[faltantes[0]][inicial];
            actual.path.push_back(faltantes[0]);
            actual.path.push_back(inicial);
            if (actual.distancia_recorrida <= costo_minimo) {
                costo_minimo = actual.distancia_recorrida;
                mejor_camino = actual.path;
            }
        } 
        else { 
            if (actual.cota_inferior <= costo_minimo ){
                vector<int> faltantes = numeros_faltantes(actual.path, points.size()-1);
                for (int i = 0; i < faltantes.size(); ++i) {
                    Nodo nuevo= actual;
                    nuevo.path.push_back(faltantes[i]);
                    nuevo.distancia_recorrida += distancias[actual.path.back()][faltantes[i]];
                    nuevo.cota_inferior = nuevo.distancia_recorrida + cota_inferior(distancias, nuevo.path);
                    no_visitados.push(nuevo);
                }
            }
        }
    }

    return mejor_camino;

}
\end{lstlisting}
\subsection{Algoritmo Branch and Bound}
El algoritmo Branch and Bound se basa en explorar sistemáticamente el espacio de soluciones posibles utilizando una estructura de árbol. Cada nodo en el árbol representa un estado parcial del problema, y el objetivo es encontrar el camino de menor costo que visite todos los nodos exactamente una vez y regrese al nodo inicial.

Primero, definimos una estructura para almacenar la información de cada nodo, que incluye el camino recorrido hasta el momento, la distancia acumulada y la cota inferior calculada.

El algoritmo comienza creando un nodo inicial que contiene solo el nodo de partida. Este nodo se agrega a una cola de prioridad, que ordena los nodos en función de sus cotas inferiores. La cola de prioridad garantiza que siempre se explora primero el nodo con la menor cota inferior.

El algoritmo procede iterativamente extrayendo el nodo con la menor cota inferior de la cola de prioridad. Si el camino representado por este nodo incluye todos los nodos excepto uno, se completa el camino agregando el último nodo y retornando al inicial. Si la distancia total de este camino es menor que el costo mínimo conocido, se actualiza la mejor solución.

Si el nodo extraído no representa una solución completa, se generan nodos hijos para cada posible extensión del camino actual, agregando un nodo no visitado. Cada nuevo nodo hijo incluye el camino extendido, la nueva distancia acumulada y una cota inferior recalculada. Solo se agregan a la cola de prioridad aquellos nodos cuya cota inferior es menor o igual al costo mínimo conocido.
\\ \\
\textbf{Notación:}
\begin{itemize}
    \item \textbf{Solución parcial:} El camino actual recorrido almacenado en el vector de nodos del nodo en cuestión.
    \item \textbf{Función poda:} Se activa cuando la cota inferior de un nodo supera el costo mínimo global conocido, eliminando así la necesidad de explorar este nodo.
    \item \textbf{Restricciones explícitas:} El siguiente nodo a seleccionar debe estar entre los nodos aún no visitados.
    \item \textbf{Restricciones implícitas:} El camino parcial de un nodo debe tener un costo menor que el costo mínimo global para ser considerado.
    \item \textbf{Árbol de estado:} El espacio de soluciones representado por todos los posibles caminos desde el nodo inicial hasta completar un circuito.
    \item \textbf{Estado del problema:} Cada nodo en el árbol de búsqueda.
    \item \textbf{Estado solución:} El nodo actual siendo evaluado.
    \item \textbf{Estado respuesta:} El mejor camino encontrado hasta el momento que cubre todos los nodos.
    \item \textbf{Nodo vivo:} Nodos que aún no han sido podados y pueden potencialmente llevar a una solución mejor.
    \item \textbf{Nodo muerto:} Nodos que han sido podados o totalmente explorados y no pueden mejorar la solución actual.
    \item \textbf{e-nodo:} El nodo actual que está siendo expandido.
    \end{itemize}


\newpage


\section{Eficiencia teórica y empírica}
\subsection{Eficiencia teórica}

En primer lugar, como ya calculamos en la práctica anterior, tenemos que la eficiencai de la cota global es de $O(n^2)$. En cuanto a las cotas locales tenemos
que: \\\\
·Para la primera cota tenemos una eficiencia de $O(n^3)$. Esto se debe a que el bucle for interno se ejecuta n veces, y en dicho bucle se realiza un if con 
una función find que a su vez también tiene eficiencia $O(n)$, por lo que dicho bucle for tiene eficiencia $O(n^2)$. Además, tenemos que el bucle for exterior 
se ejecuta n veces, por lo que finalmente obtenemos una eficiencia $O(n^3)$.\\\\
·Para la segunda cota tenemos por el mismo razonamiento una eficiencia de $O(n^3)$.\\\\
Ahora veamos la eficiencia del algoritmo Branch and Bound. Empezando por la parte más interna del código, tenemos una estructura if-else. En dicha estructura,
el bloque de sentencias if tienen una eficiencia $O(nlog(n))$ debido a que llama a la funcion numeros faltantes cuya eficiencia se ve claramente, debido a que 
se ejecuta en un bucle for n veces un if cuya condición es $O(log(n))$.
\begin{lstlisting}
vector<int> numeros_faltantes(const vector<int>& vec, int n) {
            
      set<int> presentes(vec.begin(), vec.end());
        
      vector<int> faltantes;
      for (int i : views::iota(0, n + 1)) {
            if (!presentes.contains(i)) {
                faltantes.push_back(i);
            }
      }
        
      return faltantes;
}
\end{lstlisting}
Por otro lado, tenemos para el else una eficiencia de $O(n^4)$, esto se debe a que hay un bucle for que se ejecuta n veces y en su cuerpo se llama a la función 
cota inferior que tiene una eficiencia de $O(n^3)$. De aquí obtenemos que la eficiencia del bloque if-else es $O(n^4)$. Como la condición del bucle while es $O(n!)$,
tenemos que la eficiencia del método Branch and Bound es de $O(n! \cdot n^4 )$. 

\subsection{Eficiencia empírica}
En cuanto a la eficiencia empírica, podemos decir que aunque ambas cotas tienen el mismo orden de eficiencia, se observa
claramente que a partir de la primera cota obtenemos mejores resultados.

\begin{figure}[H]
      \centering
      \begin{minipage}{.48\textwidth}
            \centering
            \includegraphics[width=1\linewidth]{assets/Img/Cota_1_BB/grafico_tiempos.png}
            \caption{Cota 1}
            \label{fig:Cota 1}
      \end{minipage}%
      \begin{minipage}{.48\textwidth}
            \centering
            \includegraphics[width=1\linewidth]{assets/Img/Cota_2_BB/grafico_tiempos.png}
            \caption{Cota 2}
            \label{fig:Cota 2}
      \end{minipage}
\end{figure}
\newpage

\section{Justificación}

Para demostrar que el algoritmo Branch and Bound que hemos creado nos proporciona una solución óptima, realizaremos una
demostración por reducción al absurdo. Proposiciones:
\begin{enumerate}
      \item Llamaremos N al conjunto de todos los nodos pertenecientes al último nivel
      \item Llamaremo T al conjunto de todos los nodos pertenecientes a niveles superiores que están podados.
      \item Llamaremos $N_A$ al nodo que nos devuelve nuestro algoritmo
      \item Llamaremos $k_i$ al camino correspondiente de $N_i$
      \item Llamaremos $c_i$ a la cota inferior local correspondiente de $N_i$
      \item Llamaremos C a la cota global
      \item Supondremos que una solución es la óptima cuando en el último nivel del árbol de estado exista
      un camino tal que $k_i \leq k_j \ \ \ \forall N_j \in N$ y que cumpla que $k_i \leq c_{ln}  \ \ \ c_{ln} \in T $ donde 
      n indica el nivel de su ultimo desarrollo, es decir, su rama esta podada 
\end{enumerate}

Procedemos ahora a realizar la reduccioón al absurdo.
Empezamos suponiendo que la solución devuelta no es la óptima, entonces pueden ocurrir dos cosas:
\begin{enumerate}
    \item Existe un nodo en el último nivel al que llamaremos $N_j$ tal que $ N_j \in N$ que cumple que
     $k_j < k_A  \ \ $  entonces  $ N_j$  sería una mejor solución que $N_A$. De hecho, en prticular, se cumpliría que
     $ \exists N_j \in N \text{tal que } k_l \leq k_i  \ \ \forall N_i \in N $. Por tanto, nuestro algoritmo hubiera 
     devuelto $N_j$ en vez de $N_A$ y llegamos a una contradicción
    \item Existiría un nodo $N_{jm} \in T \text{tal que } c_{jm} < K_A = C$ del nivel m, donde la rama estaría podada
    por lo que llegamos a una contradicción, ya que debería seguir desarrollandose al ser menor que la cota global. 
\end{enumerate}

Como podemos ver en ambos casos llegamos a contracción que es lo que buscábamos

\newpage

\section{Gráficas}
Finalmente, mostraremos varias ejecuciones del algoritmo del viajante mediante el Branch and Bound. Mostraremos gráficas realizadas con ambas
cotas aunque eso no se ve reflejado en el resultado final sino más bien en el tiempo de ejecución como hemos mostrado previamente.

\begin{figure}[H]
      \centering
      \begin{minipage}{.48\textwidth}
            \centering
            \includegraphics[width=1\linewidth]{assets/Img/Cota_1_BB/grafico_8_1.png}
            \caption{Cota 1, 8 puntos}
            \label{fig:Cota 1}
      \end{minipage}%
      \begin{minipage}{.48\textwidth}
            \centering
            \includegraphics[width=1\linewidth]{assets/Img/Cota_2_BB/grafico_8_1.png}
            \caption{Cota 2, 8 puntos}
            \label{fig:Cota 2}
      \end{minipage}
\end{figure}

\begin{figure}[H]
      \centering
      \begin{minipage}{.48\textwidth}
            \centering
            \includegraphics[width=1\linewidth]{assets/Img/Cota_1_BB/grafico_12_1.png}
            \caption{Cota 1, 12 puntos}
            \label{fig:Cota 1}
      \end{minipage}%
      \begin{minipage}{.48\textwidth}
            \centering
            \includegraphics[width=1\linewidth]{assets/Img/Cota_2_BB/grafico_12_1.png}
            \caption{Cota 2, 12 puntos}
            \label{fig:Cota 2}
      \end{minipage}
\end{figure}

A simple vista podemos apreciar que verdaderamenta obtenemos resultados correctos independietmente de la 
cota utilizada, sin embargo, sigue siendo un factor a tener en cuenta devido a la diferencia de tiempo a la 
hora de la ejecución.
\end{document}
